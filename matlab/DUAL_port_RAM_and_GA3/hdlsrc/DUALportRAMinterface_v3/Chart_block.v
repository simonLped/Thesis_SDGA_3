// -------------------------------------------------------------
// 
// File Name: DUAL_port_RAM_and_GA3\hdlsrc\DUALportRAMinterface_v3\Chart_block.v
// Created: 2024-05-04 07:38:49
// 
// Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Chart_block
// Source Path: DUALportRAMinterface_v3/PL/integration_block1/GA_main/coefficent_array/Chart
// Hierarchy Level: 4
// Model version: 1.38
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Chart_block
          (clk,
           reset_x,
           enb,
           index,
           start_sort,
           swaps_in,
           swap_signal,
           index_increment,
           index_reset,
           sort_done,
           commit_swap,
           swaps_increment,
           reset_swaps);

  // Default encoded enumeration values for type state_type_is_Chart1
  parameter state_type_is_Chart1_IN_done_state = 3'd0, state_type_is_Chart1_IN_index_increment = 3'd1, state_type_is_Chart1_IN_initial_sort = 3'd2, state_type_is_Chart1_IN_not_perform_swap = 3'd3, state_type_is_Chart1_IN_perform_swap = 3'd4, state_type_is_Chart1_IN_round_increment = 3'd5, state_type_is_Chart1_IN_start_round = 3'd6;

  input   clk;
  input   reset_x;
  input   enb;
  input   [3:0] index;  // ufix4
  input   start_sort;
  input   [3:0] swaps_in;  // ufix4
  input   swap_signal;
  output  index_increment;
  output  index_reset;
  output  sort_done;
  output  [3:0] commit_swap;  // ufix4
  output  swaps_increment;
  output  reset_swaps;


  reg [2:0] is_Chart;  // uint8
  reg  index_increment_reg;
  reg  index_reset_reg;
  reg  sort_done_reg;
  reg [3:0] commit_swap_reg;  // ufix4
  reg  swaps_increment_reg;
  reg  reset_swaps_reg;
  reg [2:0] is_Chart_next;  // enum type state_type_is_Chart1 (7 enums)
  reg  index_increment_reg_next;
  reg  index_reset_reg_next;
  reg  sort_done_reg_next;
  reg [3:0] commit_swap_reg_next;  // ufix4
  reg  swaps_increment_reg_next;
  reg  reset_swaps_reg_next;


  always @(posedge clk)
    begin : Chart_process
      if (reset_x == 1'b0) begin
        index_increment_reg <= 1'b0;
        index_reset_reg <= 1'b0;
        sort_done_reg <= 1'b0;
        commit_swap_reg <= 4'b0000;
        swaps_increment_reg <= 1'b0;
        reset_swaps_reg <= 1'b0;
        is_Chart <= state_type_is_Chart1_IN_initial_sort;
      end
      else begin
        if (enb) begin
          is_Chart <= is_Chart_next;
          index_increment_reg <= index_increment_reg_next;
          index_reset_reg <= index_reset_reg_next;
          sort_done_reg <= sort_done_reg_next;
          commit_swap_reg <= commit_swap_reg_next;
          swaps_increment_reg <= swaps_increment_reg_next;
          reset_swaps_reg <= reset_swaps_reg_next;
        end
      end
    end

  always @(commit_swap_reg, index, index_increment_reg, index_reset_reg, is_Chart,
       reset_swaps_reg, sort_done_reg, start_sort, swap_signal, swaps_in,
       swaps_increment_reg) begin
    index_increment_reg_next = index_increment_reg;
    index_reset_reg_next = index_reset_reg;
    sort_done_reg_next = sort_done_reg;
    commit_swap_reg_next = commit_swap_reg;
    swaps_increment_reg_next = swaps_increment_reg;
    reset_swaps_reg_next = reset_swaps_reg;
    is_Chart_next = is_Chart;
    case ( is_Chart)
      state_type_is_Chart1_IN_done_state :
        begin
          is_Chart_next = state_type_is_Chart1_IN_initial_sort;
        end
      state_type_is_Chart1_IN_index_increment :
        begin
          index_increment_reg_next = 1'b0;
          is_Chart_next = state_type_is_Chart1_IN_start_round;
          reset_swaps_reg_next = 1'b0;
          index_reset_reg_next = 1'b0;
        end
      state_type_is_Chart1_IN_initial_sort :
        begin
          if (start_sort) begin
            is_Chart_next = state_type_is_Chart1_IN_start_round;
            reset_swaps_reg_next = 1'b0;
            index_reset_reg_next = 1'b0;
          end
          else begin
            index_increment_reg_next = 1'b0;
            index_reset_reg_next = 1'b1;
            swaps_increment_reg_next = 1'b0;
            reset_swaps_reg_next = 1'b1;
            sort_done_reg_next = 1'b0;
          end
        end
      state_type_is_Chart1_IN_not_perform_swap :
        begin
          if (index < 4'b0011) begin
            is_Chart_next = state_type_is_Chart1_IN_index_increment;
            index_increment_reg_next = 1'b1;
          end
          else if (swaps_in == 4'b0000) begin
            is_Chart_next = state_type_is_Chart1_IN_done_state;
            sort_done_reg_next = 1'b1;
          end
          else if (index == 4'b0011) begin
            is_Chart_next = state_type_is_Chart1_IN_round_increment;
            index_reset_reg_next = 1'b1;
            reset_swaps_reg_next = 1'b1;
          end
        end
      state_type_is_Chart1_IN_perform_swap :
        begin
          if (index == 4'b0011) begin
            commit_swap_reg_next = 4'b0000;
            swaps_increment_reg_next = 1'b0;
            is_Chart_next = state_type_is_Chart1_IN_round_increment;
            index_reset_reg_next = 1'b1;
            reset_swaps_reg_next = 1'b1;
          end
          else if (index < 4'b0011) begin
            commit_swap_reg_next = 4'b0000;
            swaps_increment_reg_next = 1'b0;
            is_Chart_next = state_type_is_Chart1_IN_index_increment;
            index_increment_reg_next = 1'b1;
          end
        end
      state_type_is_Chart1_IN_round_increment :
        begin
          is_Chart_next = state_type_is_Chart1_IN_start_round;
          reset_swaps_reg_next = 1'b0;
          index_reset_reg_next = 1'b0;
        end
      default :
        begin
          //case IN_start_round:
          if ( ! swap_signal) begin
            is_Chart_next = state_type_is_Chart1_IN_not_perform_swap;
            commit_swap_reg_next = 4'b0000;
          end
          else if (index == 4'b0100) begin
            is_Chart_next = state_type_is_Chart1_IN_round_increment;
            index_reset_reg_next = 1'b1;
            reset_swaps_reg_next = 1'b1;
          end
          else if (swap_signal) begin
            is_Chart_next = state_type_is_Chart1_IN_perform_swap;
            commit_swap_reg_next = index;
            swaps_increment_reg_next = 1'b1;
          end
        end
    endcase
  end

  assign index_increment = index_increment_reg_next;
  assign index_reset = index_reset_reg_next;
  assign sort_done = sort_done_reg_next;
  assign commit_swap = commit_swap_reg_next;
  assign swaps_increment = swaps_increment_reg_next;
  assign reset_swaps = reset_swaps_reg_next;



endmodule  // Chart_block

