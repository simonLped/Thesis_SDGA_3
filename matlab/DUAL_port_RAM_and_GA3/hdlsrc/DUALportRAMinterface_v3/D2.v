// -------------------------------------------------------------
// 
// File Name: DUAL_port_RAM_and_GA3\hdlsrc\DUALportRAMinterface_v3\D2.v
// Created: 2024-05-04 07:38:49
// 
// Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: D2
// Source Path: DUALportRAMinterface_v3/PL/integration_block1/D2
// Hierarchy Level: 2
// Model version: 1.38
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module D2
          (clk,
           reset_x,
           enb,
           GAerror,
           push_individual,
           reset_D2,
           Individual_input_0,
           Individual_input_1,
           Individual_input_2,
           Individual_input_3,
           Individual_input_4,
           Individual_input_5,
           Individual_input_6,
           response);


  input   clk;
  input   reset_x;
  input   enb;
  input   signed [15:0] GAerror;  // sfix16_En14
  input   push_individual;
  input   reset_D2;
  input   signed [32:0] Individual_input_0;  // sfix33_En15
  input   signed [32:0] Individual_input_1;  // sfix33_En15
  input   signed [32:0] Individual_input_2;  // sfix33_En15
  input   signed [32:0] Individual_input_3;  // sfix33_En15
  input   signed [32:0] Individual_input_4;  // sfix33_En15
  input   signed [32:0] Individual_input_5;  // sfix33_En15
  input   signed [32:0] Individual_input_6;  // sfix33_En15
  output  signed [13:0] response;  // sfix14_En12


  wire switch_compare_1;
  wire switch_compare_1_1;
  wire signed [32:0] individual1_out1deadOutdeadOut;  // sfix33_En15
  wire signed [32:0] individual1_out2;  // sfix33_En15
  wire signed [32:0] individual1_out3;  // sfix33_En15
  wire signed [32:0] individual1_out4;  // sfix33_En15
  wire signed [32:0] individual1_out5;  // sfix33_En15
  wire signed [32:0] individual1_out6;  // sfix33_En15
  wire signed [32:0] individual1_out7;  // sfix33_En15
  wire switch_compare_1_2;
  wire switch_compare_1_3;
  reg signed [63:0] s_state_out2_out1;  // sfix64_En32
  reg signed [63:0] s_state_out3_out1;  // sfix64_En32
  wire signed [96:0] Product_mul_temp;  // sfix97_En47
  wire signed [63:0] Product_out1;  // sfix64_En32
  wire signed [63:0] reset_sw4_out1;  // sfix64_En32
  reg signed [63:0] s_state_out11_out1;  // sfix64_En32
  wire signed [96:0] Product1_mul_temp;  // sfix97_En47
  wire signed [63:0] Product1_out1;  // sfix64_En32
  wire signed [63:0] reset_sw5_out1;  // sfix64_En32
  wire signed [63:0] denom_acc3_out1;  // sfix64_En32
  wire signed [96:0] Product2_mul_temp;  // sfix97_En47
  wire signed [63:0] Product2_out1;  // sfix64_En32
  wire signed [63:0] reset_sw6_out1;  // sfix64_En32
  wire signed [63:0] denom_acc11_sub_cast;  // sfix64_En32
  wire signed [63:0] denom_acc11_out1;  // sfix64_En32
  wire signed [63:0] denom_acc2_out1;  // sfix64_En32
  wire switch_compare_1_4;
  wire switch_compare_1_5;
  wire switch_compare_1_6;
  wire signed [63:0] reset_sw3_out1;  // sfix64_En32
  wire signed [96:0] Product5_mul_temp;  // sfix97_En47
  wire signed [63:0] Product5_out1;  // sfix64_En32
  wire signed [63:0] reset_sw_out1;  // sfix64_En32
  wire signed [63:0] s_nume_acc11_out1;  // sfix64_En32
  wire signed [96:0] Product4_mul_temp;  // sfix97_En47
  wire signed [63:0] Product4_out1;  // sfix64_En32
  wire signed [63:0] reset_sw1_out1;  // sfix64_En32
  wire signed [63:0] s_nume_acc2_out1;  // sfix64_En32
  wire signed [96:0] Product3_mul_temp;  // sfix97_En47
  wire signed [63:0] Product3_out1;  // sfix64_En32
  wire signed [63:0] reset_sw2_out1;  // sfix64_En32
  wire signed [64:0] s_nume_acc3_add_cast;  // sfix65_En32
  wire signed [64:0] s_nume_acc3_add_cast_1;  // sfix65_En32
  wire signed [64:0] s_nume_acc3_add_temp;  // sfix65_En32
  wire signed [13:0] s_nume_acc3_out1;  // sfix14_En12
  wire signed [13:0] output_cast1_out1;  // sfix14_En12


  assign switch_compare_1 = reset_D2 > 1'b0;



  assign switch_compare_1_1 = reset_D2 > 1'b0;



  individual1_block1 u_individual1 (.clk(clk),
                                    .reset_x(reset_x),
                                    .enb(enb),
                                    .reg_in(Individual_input_0),  // sfix33_En15
                                    .reg_in1(Individual_input_1),  // sfix33_En15
                                    .reg_in2(Individual_input_2),  // sfix33_En15
                                    .reg_in3(Individual_input_3),  // sfix33_En15
                                    .reg_in4(Individual_input_4),  // sfix33_En15
                                    .reg_in5(Individual_input_5),  // sfix33_En15
                                    .reg_in6(Individual_input_6),  // sfix33_En15
                                    .enable(push_individual),
                                    .score(individual1_out1deadOutdeadOut),  // sfix33_En15
                                    .a2(individual1_out2),  // sfix33_En15
                                    .a3(individual1_out3),  // sfix33_En15
                                    .a4(individual1_out4),  // sfix33_En15
                                    .b2(individual1_out5),  // sfix33_En15
                                    .b3(individual1_out6),  // sfix33_En15
                                    .b4(individual1_out7)  // sfix33_En15
                                    );

  assign switch_compare_1_2 = reset_D2 > 1'b0;



  assign switch_compare_1_3 = reset_D2 > 1'b0;



  always @(posedge clk)
    begin : s_state_out3_process
      if (reset_x == 1'b0) begin
        s_state_out3_out1 <= 64'sh0000000000000000;
      end
      else begin
        if (enb) begin
          s_state_out3_out1 <= s_state_out2_out1;
        end
      end
    end



  assign Product_mul_temp = s_state_out3_out1 * individual1_out7;
  assign Product_out1 = Product_mul_temp[78:15];



  assign reset_sw4_out1 = (switch_compare_1_3 == 1'b0 ? Product_out1 :
              64'sh0000000000000000);



  always @(posedge clk)
    begin : s_state_out2_process
      if (reset_x == 1'b0) begin
        s_state_out2_out1 <= 64'sh0000000000000000;
      end
      else begin
        if (enb) begin
          s_state_out2_out1 <= s_state_out11_out1;
        end
      end
    end



  assign Product1_mul_temp = s_state_out2_out1 * individual1_out6;
  assign Product1_out1 = Product1_mul_temp[78:15];



  assign reset_sw5_out1 = (switch_compare_1_2 == 1'b0 ? Product1_out1 :
              64'sh0000000000000000);



  always @(posedge clk)
    begin : s_state_out11_process
      if (reset_x == 1'b0) begin
        s_state_out11_out1 <= 64'sh0000000000000000;
      end
      else begin
        if (enb) begin
          s_state_out11_out1 <= denom_acc3_out1;
        end
      end
    end



  assign Product2_mul_temp = s_state_out11_out1 * individual1_out5;
  assign Product2_out1 = Product2_mul_temp[78:15];



  assign reset_sw6_out1 = (switch_compare_1_1 == 1'b0 ? Product2_out1 :
              64'sh0000000000000000);



  assign denom_acc11_sub_cast = {{30{GAerror[15]}}, {GAerror, 18'b000000000000000000}};
  assign denom_acc11_out1 = denom_acc11_sub_cast - reset_sw6_out1;



  assign denom_acc2_out1 = denom_acc11_out1 - reset_sw5_out1;



  assign denom_acc3_out1 = denom_acc2_out1 - reset_sw4_out1;



  assign switch_compare_1_4 = reset_D2 > 1'b0;



  assign switch_compare_1_5 = reset_D2 > 1'b0;



  assign switch_compare_1_6 = reset_D2 > 1'b0;



  assign reset_sw3_out1 = (switch_compare_1 == 1'b0 ? denom_acc3_out1 :
              64'sh0000000000000000);



  assign Product5_mul_temp = s_state_out11_out1 * individual1_out2;
  assign Product5_out1 = Product5_mul_temp[78:15];



  assign reset_sw_out1 = (switch_compare_1_4 == 1'b0 ? Product5_out1 :
              64'sh0000000000000000);



  assign s_nume_acc11_out1 = reset_sw3_out1 + reset_sw_out1;



  assign Product4_mul_temp = s_state_out2_out1 * individual1_out3;
  assign Product4_out1 = Product4_mul_temp[78:15];



  assign reset_sw1_out1 = (switch_compare_1_5 == 1'b0 ? Product4_out1 :
              64'sh0000000000000000);



  assign s_nume_acc2_out1 = s_nume_acc11_out1 + reset_sw1_out1;



  assign Product3_mul_temp = s_state_out3_out1 * individual1_out4;
  assign Product3_out1 = Product3_mul_temp[78:15];



  assign reset_sw2_out1 = (switch_compare_1_6 == 1'b0 ? Product3_out1 :
              64'sh0000000000000000);



  assign s_nume_acc3_add_cast = {s_nume_acc2_out1[63], s_nume_acc2_out1};
  assign s_nume_acc3_add_cast_1 = {reset_sw2_out1[63], reset_sw2_out1};
  assign s_nume_acc3_add_temp = s_nume_acc3_add_cast + s_nume_acc3_add_cast_1;
  assign s_nume_acc3_out1 = s_nume_acc3_add_temp[33:20];



  output_cast1 u_output_cast1 (.in(s_nume_acc3_out1),  // sfix14_En12
                               .out(output_cast1_out1)  // sfix14_En12
                               );

  assign response = output_cast1_out1;

endmodule  // D2

