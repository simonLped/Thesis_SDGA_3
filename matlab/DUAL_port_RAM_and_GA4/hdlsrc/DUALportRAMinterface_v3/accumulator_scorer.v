// -------------------------------------------------------------
// 
// File Name: DUAL_port_RAM_and_GA4\hdlsrc\DUALportRAMinterface_v3\accumulator_scorer.v
// Created: 2024-05-15 10:45:59
// 
// Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: accumulator_scorer
// Source Path: DUALportRAMinterface_v3/PL/integration_block1/accumulator_scorer
// Hierarchy Level: 2
// Model version: 1.52
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module accumulator_scorer
          (clk,
           reset_x,
           enb,
           data_in_re,
           data_in_im,
           valid_fft,
           individual_score,
           individual_score_valid);


  input   clk;
  input   reset_x;
  input   enb;
  input   signed [27:0] data_in_re;  // sfix28_En14
  input   signed [27:0] data_in_im;  // sfix28_En14
  input   valid_fft;
  output  signed [32:0] individual_score;  // sfix33_En15
  output  individual_score_valid;


  reg  [4031:0] Delay3_reg;  // ufix1 [4032]
  wire Delay3_out1;
  wire Logical_Operator1_out1;
  wire signed [25:0] Constant19_out1;  // sfix26_En12
  wire switch_compare_1;
  wire signed [25:0] Constant1_out1;  // sfix26_En12
  wire signed [27:0] Real_Imag_to_Complex_out1_dtc_re;  // sfix28_En14
  wire signed [27:0] Real_Imag_to_Complex_out1_dtc_im;  // sfix28_En14
  wire signed [27:0] Switch_out1_re;  // sfix28_En14
  wire signed [27:0] Switch_out1_im;  // sfix28_En14
  wire signed [63:0] Data_Type_Conversion_out1;  // sfix64_En32
  wire signed [127:0] multiplier_mul_temp;  // sfix128_En64
  wire signed [63:0] Magnitude_Square1_out1;  // sfix64_En32
  wire signed [63:0] Data_Type_Conversion1_out1;  // sfix64_En32
  wire signed [127:0] multiplier_mul_temp_1;  // sfix128_En64
  wire signed [63:0] Magnitude_Square2_out1;  // sfix64_En32
  wire signed [64:0] Add2_add_cast;  // sfix65_En32
  wire signed [64:0] Add2_add_cast_1;  // sfix65_En32
  wire signed [64:0] Add2_add_temp;  // sfix65_En32
  wire signed [63:0] Add2_out1;  // sfix64_En32
  wire signed [5:0] alpha64bitmsb_finder_out1;  // sfix6
  wire switch_compare_1_1;
  wire signed [63:0] Constant20_out1;  // sfix64_En32
  reg signed [63:0] Delay_out1;  // sfix64_En32
  wire signed [63:0] Switch8_out1;  // sfix64_En32
  wire signed [63:0] Add_add_cast;  // sfix64_En32
  wire signed [64:0] Add_add_cast_1;  // sfix65_En32
  wire signed [64:0] Add_add_cast_2;  // sfix65_En32
  wire signed [64:0] Add_add_temp;  // sfix65_En32
  wire signed [63:0] Add_out1;  // sfix64_En32
  wire signed [32:0] Data_Type_Conversion2_out1;  // sfix33_En15
  reg  [62:0] Delay1_reg;  // ufix1 [63]
  wire Delay1_out1;
  wire Logical_Operator2_out1;
  reg  Delay2_out1;


  always @(posedge clk)
    begin : Delay3_process
      if (reset_x == 1'b0) begin
        Delay3_reg <= {4032{1'b0}};
      end
      else begin
        if (enb) begin
          Delay3_reg[0] <= valid_fft;
          Delay3_reg[32'sd4031:32'sd1] <= Delay3_reg[32'sd4030:32'sd0];
        end
      end
    end

  assign Delay3_out1 = Delay3_reg[4031];



  assign Logical_Operator1_out1 = valid_fft & Delay3_out1;



  assign Constant19_out1 = 26'sb00000000000000000000000000;



  assign switch_compare_1 = Logical_Operator1_out1 > 1'b0;



  assign Constant1_out1 = 26'sb00000000000000000000000000;



  assign Real_Imag_to_Complex_out1_dtc_re = {Constant19_out1, 2'b00};
  assign Real_Imag_to_Complex_out1_dtc_im = {Constant1_out1, 2'b00};



  assign Switch_out1_re = (switch_compare_1 == 1'b0 ? Real_Imag_to_Complex_out1_dtc_re :
              data_in_re);
  assign Switch_out1_im = (switch_compare_1 == 1'b0 ? Real_Imag_to_Complex_out1_dtc_im :
              data_in_im);



  assign Data_Type_Conversion_out1 = {{18{Switch_out1_re[27]}}, {Switch_out1_re, 18'b000000000000000000}};



  assign multiplier_mul_temp = Data_Type_Conversion_out1 * Data_Type_Conversion_out1;
  assign Magnitude_Square1_out1 = ((multiplier_mul_temp[127] == 1'b0) && (multiplier_mul_temp[126:95] != 32'b00000000000000000000000000000000) ? 64'sh7FFFFFFFFFFFFFFF :
              ((multiplier_mul_temp[127] == 1'b1) && (multiplier_mul_temp[126:95] != 32'b11111111111111111111111111111111) ? 64'sh8000000000000000 :
              multiplier_mul_temp[95:32] + $signed({1'b0, multiplier_mul_temp[127] & (|multiplier_mul_temp[31:0])})));



  assign Data_Type_Conversion1_out1 = {{18{Switch_out1_im[27]}}, {Switch_out1_im, 18'b000000000000000000}};



  assign multiplier_mul_temp_1 = Data_Type_Conversion1_out1 * Data_Type_Conversion1_out1;
  assign Magnitude_Square2_out1 = ((multiplier_mul_temp_1[127] == 1'b0) && (multiplier_mul_temp_1[126:95] != 32'b00000000000000000000000000000000) ? 64'sh7FFFFFFFFFFFFFFF :
              ((multiplier_mul_temp_1[127] == 1'b1) && (multiplier_mul_temp_1[126:95] != 32'b11111111111111111111111111111111) ? 64'sh8000000000000000 :
              multiplier_mul_temp_1[95:32] + $signed({1'b0, multiplier_mul_temp_1[127] & (|multiplier_mul_temp_1[31:0])})));



  assign Add2_add_cast = {Magnitude_Square1_out1[63], Magnitude_Square1_out1};
  assign Add2_add_cast_1 = {Magnitude_Square2_out1[63], Magnitude_Square2_out1};
  assign Add2_add_temp = Add2_add_cast + Add2_add_cast_1;
  assign Add2_out1 = ((Add2_add_temp[64] == 1'b0) && (Add2_add_temp[63] != 1'b0) ? 64'sh7FFFFFFFFFFFFFFF :
              ((Add2_add_temp[64] == 1'b1) && (Add2_add_temp[63] != 1'b1) ? 64'sh8000000000000000 :
              $signed(Add2_add_temp[63:0])));



  alpha64bitmsb_finder u_64bitmsb_finder (.u_port(Add2_out1),  // sfix64_En32
                                          .out1(alpha64bitmsb_finder_out1)  // sfix6
                                          );

  assign switch_compare_1_1 = Logical_Operator1_out1 > 1'b0;



  assign Constant20_out1 = 64'sh0000000000000000;



  assign Switch8_out1 = (switch_compare_1_1 == 1'b0 ? Constant20_out1 :
              Delay_out1);



  assign Add_add_cast = {{26{alpha64bitmsb_finder_out1[5]}}, {alpha64bitmsb_finder_out1, 32'b00000000000000000000000000000000}};
  assign Add_add_cast_1 = {Add_add_cast[63], Add_add_cast};
  assign Add_add_cast_2 = {Switch8_out1[63], Switch8_out1};
  assign Add_add_temp = Add_add_cast_1 + Add_add_cast_2;
  assign Add_out1 = ((Add_add_temp[64] == 1'b0) && (Add_add_temp[63] != 1'b0) ? 64'sh7FFFFFFFFFFFFFFF :
              ((Add_add_temp[64] == 1'b1) && (Add_add_temp[63] != 1'b1) ? 64'sh8000000000000000 :
              $signed(Add_add_temp[63:0])));



  always @(posedge clk)
    begin : Delay_process
      if (reset_x == 1'b0) begin
        Delay_out1 <= 64'sh0000000000000000;
      end
      else begin
        if (enb) begin
          Delay_out1 <= Add_out1;
        end
      end
    end



  assign Data_Type_Conversion2_out1 = Delay_out1[49:17];



  assign individual_score = Data_Type_Conversion2_out1;

  always @(posedge clk)
    begin : Delay1_process
      if (reset_x == 1'b0) begin
        Delay1_reg <= {63{1'b0}};
      end
      else begin
        if (enb) begin
          Delay1_reg[0] <= Logical_Operator1_out1;
          Delay1_reg[32'sd62:32'sd1] <= Delay1_reg[32'sd61:32'sd0];
        end
      end
    end

  assign Delay1_out1 = Delay1_reg[62];



  assign Logical_Operator2_out1 = Delay1_out1 & Logical_Operator1_out1;



  always @(posedge clk)
    begin : Delay2_process
      if (reset_x == 1'b0) begin
        Delay2_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= Logical_Operator2_out1;
        end
      end
    end



  assign individual_score_valid = Delay2_out1;

endmodule  // accumulator_scorer

