// -------------------------------------------------------------
// 
// File Name: DUAL_port_RAM_and_GA4\hdlsrc\DUALportRAMinterface_v3\PL_tb.v
// Created: 2024-05-15 10:47:38
// 
// Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 7.50008e-06
// Target subsystem base rate: 7.50008e-06
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: PL_tb
// Source Path: 
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module PL_tb;



  reg  clk;
  reg  reset_x;
  wire clk_enable;
  wire rawData_START_GA;
  wire bram_we_done;  // ufix1
  wire rdEnb;
  wire bram_we_done_enb;  // ufix1
  reg [13:0] bram_din_addr;  // ufix14
  wire bram_we_lastAddr;  // ufix1
  reg  check5_done;  // ufix1
  wire PL_done_done;  // ufix1
  wire PL_done_done_enb;  // ufix1
  wire PL_done_lastAddr;  // ufix1
  reg  check4_done;  // ufix1
  wire bram_en_done;  // ufix1
  wire bram_en_done_enb;  // ufix1
  wire bram_en_lastAddr;  // ufix1
  reg  check3_done;  // ufix1
  wire bram_addr_done;  // ufix1
  wire bram_addr_done_enb;  // ufix1
  wire bram_addr_lastAddr;  // ufix1
  reg  check2_done;  // ufix1
  wire bram_din_done;  // ufix1
  wire bram_din_done_enb;  // ufix1
  wire bram_din_active;  // ufix1
  reg [13:0] read_data_out1_addr;  // ufix14
  wire read_data_out1_active;  // ufix1
  reg  tb_enb_delay;
  wire read_data_out1_enb;  // ufix1
  wire [13:0] Dual_Port_RAM_System_out2_addr_delay_1;  // ufix14
  reg signed [31:0] fp_bram_dout;  // sfix32
  reg [31:0] rawData_bram_dout;  // uint32
  reg signed [31:0] status_bram_dout;  // sfix32
  reg [31:0] holdData_bram_dout;  // uint32
  reg [31:0] bram_dout_offset;  // uint32
  wire [31:0] bram_dout;  // uint32
  reg  holdData_START_GA;
  reg  START_GA_offset;
  wire START_GA_1;
  wire snkDone;
  wire snkDonen;
  wire tb_enb;
  wire ce_out;
  wire [31:0] bram_din;  // uint32
  wire [15:0] bram_addr;  // uint16
  wire bram_en;
  wire PL_done;
  wire [3:0] bram_we;  // ufix4
  wire bram_din_enb;  // ufix1
  wire bram_din_lastAddr;  // ufix1
  reg  check1_done;  // ufix1
  wire [31:0] bram_din_expected_1;  // uint32
  wire [31:0] bram_din_ref;  // uint32
  reg  bram_din_testFailure;  // ufix1
  wire [15:0] bram_addr_expected_1;  // uint16
  wire [15:0] bram_addr_ref;  // uint16
  reg  bram_addr_testFailure;  // ufix1
  wire bram_en_expected_1;
  wire bram_en_ref;
  reg  bram_en_testFailure;  // ufix1
  wire PL_done_expected_1;
  wire PL_done_ref;
  reg  PL_done_testFailure;  // ufix1
  wire [3:0] bram_we_expected_1;  // ufix4
  wire [3:0] bram_we_ref;  // ufix4
  reg  bram_we_testFailure;  // ufix1
  wire testFailure;  // ufix1


  // Data source for START_GA
  assign rawData_START_GA = 1'b0;



  assign bram_we_done_enb = bram_we_done & rdEnb;



  assign bram_we_lastAddr = bram_din_addr >= 14'b11010000010101;



  assign bram_we_done = bram_we_lastAddr & reset_x;



  // Delay to allow last sim cycle to complete
  always @(posedge clk)
    begin : checkDone_5
      if (!reset_x) begin
        check5_done <= 0;
      end
      else begin
        if (bram_we_done_enb) begin
          check5_done <= bram_we_done;
        end
      end
    end

  assign PL_done_done_enb = PL_done_done & rdEnb;



  assign PL_done_lastAddr = bram_din_addr >= 14'b11010000010101;



  assign PL_done_done = PL_done_lastAddr & reset_x;



  // Delay to allow last sim cycle to complete
  always @(posedge clk)
    begin : checkDone_4
      if (!reset_x) begin
        check4_done <= 0;
      end
      else begin
        if (PL_done_done_enb) begin
          check4_done <= PL_done_done;
        end
      end
    end

  assign bram_en_done_enb = bram_en_done & rdEnb;



  assign bram_en_lastAddr = bram_din_addr >= 14'b11010000010101;



  assign bram_en_done = bram_en_lastAddr & reset_x;



  // Delay to allow last sim cycle to complete
  always @(posedge clk)
    begin : checkDone_3
      if (!reset_x) begin
        check3_done <= 0;
      end
      else begin
        if (bram_en_done_enb) begin
          check3_done <= bram_en_done;
        end
      end
    end

  assign bram_addr_done_enb = bram_addr_done & rdEnb;



  assign bram_addr_lastAddr = bram_din_addr >= 14'b11010000010101;



  assign bram_addr_done = bram_addr_lastAddr & reset_x;



  // Delay to allow last sim cycle to complete
  always @(posedge clk)
    begin : checkDone_2
      if (!reset_x) begin
        check2_done <= 0;
      end
      else begin
        if (bram_addr_done_enb) begin
          check2_done <= bram_addr_done;
        end
      end
    end

  assign bram_din_done_enb = bram_din_done & rdEnb;



  assign bram_din_active = bram_din_addr != 14'b11010000010101;



  assign read_data_out1_active = read_data_out1_addr != 14'b11010000010101;



  assign read_data_out1_enb = read_data_out1_active & (rdEnb & tb_enb_delay);



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 13333
  always @(posedge clk)
    begin : read_data_process
      if (reset_x == 1'b0) begin
        read_data_out1_addr <= 14'b00000000000000;
      end
      else begin
        if (read_data_out1_enb) begin
          if (read_data_out1_addr >= 14'b11010000010101) begin
            read_data_out1_addr <= 14'b00000000000000;
          end
          else begin
            read_data_out1_addr <= read_data_out1_addr + 14'b00000000000001;
          end
        end
      end
    end



  assign #1 Dual_Port_RAM_System_out2_addr_delay_1 = read_data_out1_addr;

  // Data source for bram_dout
  initial
    begin : bram_dout_fileread
      fp_bram_dout = $fopen("bram_dout.dat", "r");
      status_bram_dout = $rewind(fp_bram_dout);
    end

  always @(Dual_Port_RAM_System_out2_addr_delay_1, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_bram_dout <= 32'bx;
      end
      else if (rdEnb == 1) begin
        status_bram_dout = $fscanf(fp_bram_dout, "%h", rawData_bram_dout);
      end
    end

  // holdData reg for Dual_Port_RAM_System_out2
  always @(posedge clk)
    begin : stimuli_Dual_Port_RAM_System_out2
      if (!reset_x) begin
        holdData_bram_dout <= 32'bx;
      end
      else begin
        holdData_bram_dout <= rawData_bram_dout;
      end
    end

  always @(rawData_bram_dout or rdEnb)
    begin : stimuli_Dual_Port_RAM_System_out2_1
      if (rdEnb == 1'b0) begin
        bram_dout_offset <= holdData_bram_dout;
      end
      else begin
        bram_dout_offset <= rawData_bram_dout;
      end
    end

  assign #2 bram_dout = bram_dout_offset;

  // holdData reg for read_data_out1
  always @(posedge clk)
    begin : stimuli_read_data_out1
      if (!reset_x) begin
        holdData_START_GA <= 1'bx;
      end
      else begin
        holdData_START_GA <= rawData_START_GA;
      end
    end

  always @(rawData_START_GA or rdEnb)
    begin : stimuli_read_data_out1_1
      if (rdEnb == 1'b0) begin
        START_GA_offset <= holdData_START_GA;
      end
      else begin
        START_GA_offset <= rawData_START_GA;
      end
    end

  assign #2 START_GA_1 = START_GA_offset;

  assign snkDonen =  ~ snkDone;



  assign tb_enb = reset_x & snkDonen;



  // Delay inside enable generation: register depth 1
  always @(posedge clk)
    begin : u_enable_delay_process
      if (reset_x == 1'b0) begin
        tb_enb_delay <= 1'b0;
      end
      else begin
        tb_enb_delay <= tb_enb;
      end
    end



  assign rdEnb = (snkDone == 1'b0 ? tb_enb_delay :
              1'b0);



  assign #2 clk_enable = rdEnb;

  initial
    begin : reset_x_gen
      reset_x <= 1'b0;
      # (20);
      @ (posedge clk)
      # (2);
      reset_x <= 1'b1;
    end

  always 
    begin : clk_gen
      clk <= 1'b1;
      # (5);
      clk <= 1'b0;
      # (5);
      if (snkDone == 1'b1) begin
        clk <= 1'b1;
        # (5);
        clk <= 1'b0;
        # (5);
        $stop;
      end
    end

  PL u_PL (.clk(clk),
           .reset_x(reset_x),
           .clk_enable(clk_enable),
           .START_GA(START_GA_1),
           .bram_dout(bram_dout),  // uint32
           .ce_out(ce_out),
           .bram_din(bram_din),  // uint32
           .bram_addr(bram_addr),  // uint16
           .bram_en(bram_en),
           .PL_done(PL_done),
           .bram_we(bram_we)  // ufix4
           );

  assign bram_din_enb = ce_out & bram_din_active;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 13333
  always @(posedge clk)
    begin : c_2_process
      if (reset_x == 1'b0) begin
        bram_din_addr <= 14'b00000000000000;
      end
      else begin
        if (bram_din_enb) begin
          if (bram_din_addr >= 14'b11010000010101) begin
            bram_din_addr <= 14'b00000000000000;
          end
          else begin
            bram_din_addr <= bram_din_addr + 14'b00000000000001;
          end
        end
      end
    end



  assign bram_din_lastAddr = bram_din_addr >= 14'b11010000010101;



  assign bram_din_done = bram_din_lastAddr & reset_x;



  // Delay to allow last sim cycle to complete
  always @(posedge clk)
    begin : checkDone_1
      if (!reset_x) begin
        check1_done <= 0;
      end
      else begin
        if (bram_din_done_enb) begin
          check1_done <= bram_din_done;
        end
      end
    end

  assign snkDone = check5_done & (check4_done & (check3_done & (check1_done & check2_done)));



  // Data source for bram_din_expected
  assign bram_din_expected_1 = 32'b00000000000000000000000000000000;



  assign bram_din_ref = bram_din_expected_1;

  always @(posedge clk)
    begin : bram_din_checker
      if (reset_x == 1'b0) begin
        bram_din_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && bram_din !== bram_din_ref) begin
          bram_din_testFailure <= 1'b1;
          $display("ERROR in bram_din at time %t : Expected '%h' Actual '%h'", $time, bram_din_ref, bram_din);
        end
      end
    end

  // Data source for bram_addr_expected
  assign bram_addr_expected_1 = 16'b0000000000000000;



  assign bram_addr_ref = bram_addr_expected_1;

  always @(posedge clk)
    begin : bram_addr_checker
      if (reset_x == 1'b0) begin
        bram_addr_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && bram_addr !== bram_addr_ref) begin
          bram_addr_testFailure <= 1'b1;
          $display("ERROR in bram_addr at time %t : Expected '%h' Actual '%h'", $time, bram_addr_ref, bram_addr);
        end
      end
    end

  // Data source for bram_en_expected
  assign bram_en_expected_1 = 1'b0;



  assign bram_en_ref = bram_en_expected_1;

  always @(posedge clk)
    begin : bram_en_checker
      if (reset_x == 1'b0) begin
        bram_en_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && bram_en !== bram_en_ref) begin
          bram_en_testFailure <= 1'b1;
          $display("ERROR in bram_en at time %t : Expected '%h' Actual '%h'", $time, bram_en_ref, bram_en);
        end
      end
    end

  // Data source for PL_done_expected
  assign PL_done_expected_1 = 1'b0;



  assign PL_done_ref = PL_done_expected_1;

  always @(posedge clk)
    begin : PL_done_checker
      if (reset_x == 1'b0) begin
        PL_done_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && PL_done !== PL_done_ref) begin
          PL_done_testFailure <= 1'b1;
          $display("ERROR in PL_done at time %t : Expected '%h' Actual '%h'", $time, PL_done_ref, PL_done);
        end
      end
    end

  // Data source for bram_we_expected
  assign bram_we_expected_1 = 4'b0000;



  assign bram_we_ref = bram_we_expected_1;

  always @(posedge clk)
    begin : bram_we_checker
      if (reset_x == 1'b0) begin
        bram_we_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && bram_we !== bram_we_ref) begin
          bram_we_testFailure <= 1'b1;
          $display("ERROR in bram_we at time %t : Expected '%h' Actual '%h'", $time, bram_we_ref, bram_we);
        end
      end
    end

  assign testFailure = bram_we_testFailure | (PL_done_testFailure | (bram_en_testFailure | (bram_din_testFailure | bram_addr_testFailure)));



  always @(posedge clk)
    begin : completed_msg
      if (snkDone == 1'b1) begin
        if (testFailure == 1'b0) begin
          $display("**************TEST COMPLETED (PASSED)**************");
        end
        else begin
          $display("**************TEST COMPLETED (FAILED)**************");
        end
      end
    end

endmodule  // PL_tb

