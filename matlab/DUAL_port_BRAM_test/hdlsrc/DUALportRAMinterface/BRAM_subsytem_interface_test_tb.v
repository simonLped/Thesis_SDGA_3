// -------------------------------------------------------------
// 
// File Name: DUAL_port_BRAM_test\hdlsrc\DUALportRAMinterface\BRAM_subsytem_interface_test_tb.v
// Created: 2024-05-13 21:12:44
// 
// Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 7.50008e-06
// Target subsystem base rate: 7.50008e-06
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: BRAM_subsytem_interface_test_tb
// Source Path: 
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module BRAM_subsytem_interface_test_tb;



  reg  clk;
  reg  reset_x;
  wire clk_enable;
  wire PL_done_done;  // ufix1
  wire rdEnb;
  wire PL_done_done_enb;  // ufix1
  reg [18:0] bram_din_addr;  // ufix19
  wire PL_done_lastAddr;  // ufix1
  reg  check4_done;  // ufix1
  wire bram_en_done;  // ufix1
  wire bram_en_done_enb;  // ufix1
  wire bram_en_lastAddr;  // ufix1
  reg  check3_done;  // ufix1
  wire bram_addr_done;  // ufix1
  wire bram_addr_done_enb;  // ufix1
  wire bram_addr_lastAddr;  // ufix1
  reg  check2_done;  // ufix1
  wire bram_din_done;  // ufix1
  wire bram_din_done_enb;  // ufix1
  wire bram_din_active;  // ufix1
  reg [18:0] read_data_out1_addr;  // ufix19
  wire read_data_out1_active;  // ufix1
  reg  tb_enb_delay;
  wire read_data_out1_enb;  // ufix1
  wire [18:0] read_data_out1_addr_delay_1;  // ufix19
  reg signed [31:0] fp_GPIO;  // sfix32
  reg  rawData_GPIO;
  reg signed [31:0] status_GPIO;  // sfix32
  reg  holdData_GPIO;
  reg  GPIO_offset;
  wire GPIO;
  wire snkDone;
  wire snkDonen;
  wire tb_enb;
  wire ce_out;
  wire [31:0] bram_din;  // uint32
  wire [15:0] bram_addr;  // uint16
  wire bram_en;
  wire PL_done;
  wire bram_din_enb;  // ufix1
  wire bram_din_lastAddr;  // ufix1
  reg  check1_done;  // ufix1
  wire [18:0] bram_din_addr_delay_1;  // ufix19
  reg signed [31:0] fp_bram_din_expected;  // sfix32
  reg [31:0] bram_din_expected;  // uint32
  reg signed [31:0] status_bram_din_expected;  // sfix32
  wire [31:0] bram_din_ref;  // uint32
  reg  bram_din_testFailure;  // ufix1
  wire [18:0] bram_addr_addr_delay_1;  // ufix19
  reg signed [31:0] fp_bram_addr_expected;  // sfix32
  reg [15:0] bram_addr_expected;  // uint16
  reg signed [31:0] status_bram_addr_expected;  // sfix32
  wire [15:0] bram_addr_ref;  // uint16
  reg  bram_addr_testFailure;  // ufix1
  wire [18:0] bram_en_addr_delay_1;  // ufix19
  reg signed [31:0] fp_bram_en_expected;  // sfix32
  reg  bram_en_expected;
  reg signed [31:0] status_bram_en_expected;  // sfix32
  wire bram_en_ref;
  reg  bram_en_testFailure;  // ufix1
  wire [18:0] PL_done_addr_delay_1;  // ufix19
  reg signed [31:0] fp_PL_done_expected;  // sfix32
  reg  PL_done_expected;
  reg signed [31:0] status_PL_done_expected;  // sfix32
  wire PL_done_ref;
  reg  PL_done_testFailure;  // ufix1
  wire testFailure;  // ufix1


  assign PL_done_done_enb = PL_done_done & rdEnb;



  assign PL_done_lastAddr = bram_din_addr >= 19'b1000001000110101000;



  assign PL_done_done = PL_done_lastAddr & reset_x;



  // Delay to allow last sim cycle to complete
  always @(posedge clk)
    begin : checkDone_4
      if (!reset_x) begin
        check4_done <= 0;
      end
      else begin
        if (PL_done_done_enb) begin
          check4_done <= PL_done_done;
        end
      end
    end

  assign bram_en_done_enb = bram_en_done & rdEnb;



  assign bram_en_lastAddr = bram_din_addr >= 19'b1000001000110101000;



  assign bram_en_done = bram_en_lastAddr & reset_x;



  // Delay to allow last sim cycle to complete
  always @(posedge clk)
    begin : checkDone_3
      if (!reset_x) begin
        check3_done <= 0;
      end
      else begin
        if (bram_en_done_enb) begin
          check3_done <= bram_en_done;
        end
      end
    end

  assign bram_addr_done_enb = bram_addr_done & rdEnb;



  assign bram_addr_lastAddr = bram_din_addr >= 19'b1000001000110101000;



  assign bram_addr_done = bram_addr_lastAddr & reset_x;



  // Delay to allow last sim cycle to complete
  always @(posedge clk)
    begin : checkDone_2
      if (!reset_x) begin
        check2_done <= 0;
      end
      else begin
        if (bram_addr_done_enb) begin
          check2_done <= bram_addr_done;
        end
      end
    end

  assign bram_din_done_enb = bram_din_done & rdEnb;



  assign bram_din_active = bram_din_addr != 19'b1000001000110101000;



  assign read_data_out1_active = read_data_out1_addr != 19'b1000001000110101000;



  assign read_data_out1_enb = read_data_out1_active & (rdEnb & tb_enb_delay);



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 266664
  always @(posedge clk)
    begin : read_data_process
      if (reset_x == 1'b0) begin
        read_data_out1_addr <= 19'b0000000000000000000;
      end
      else begin
        if (read_data_out1_enb) begin
          if (read_data_out1_addr >= 19'b1000001000110101000) begin
            read_data_out1_addr <= 19'b0000000000000000000;
          end
          else begin
            read_data_out1_addr <= read_data_out1_addr + 19'b0000000000000000001;
          end
        end
      end
    end



  assign #1 read_data_out1_addr_delay_1 = read_data_out1_addr;

  // Data source for GPIO
  initial
    begin : GPIO_fileread
      fp_GPIO = $fopen("GPIO.dat", "r");
      status_GPIO = $rewind(fp_GPIO);
    end

  always @(read_data_out1_addr_delay_1, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_GPIO <= 1'bx;
      end
      else if (rdEnb == 1) begin
        status_GPIO = $fscanf(fp_GPIO, "%h", rawData_GPIO);
      end
    end

  // holdData reg for read_data_out1
  always @(posedge clk)
    begin : stimuli_read_data_out1
      if (!reset_x) begin
        holdData_GPIO <= 1'bx;
      end
      else begin
        holdData_GPIO <= rawData_GPIO;
      end
    end

  always @(rawData_GPIO or rdEnb)
    begin : stimuli_read_data_out1_1
      if (rdEnb == 1'b0) begin
        GPIO_offset <= holdData_GPIO;
      end
      else begin
        GPIO_offset <= rawData_GPIO;
      end
    end

  assign #2 GPIO = GPIO_offset;

  assign snkDonen =  ~ snkDone;



  assign tb_enb = reset_x & snkDonen;



  // Delay inside enable generation: register depth 1
  always @(posedge clk)
    begin : u_enable_delay_process
      if (reset_x == 1'b0) begin
        tb_enb_delay <= 1'b0;
      end
      else begin
        tb_enb_delay <= tb_enb;
      end
    end



  assign rdEnb = (snkDone == 1'b0 ? tb_enb_delay :
              1'b0);



  assign #2 clk_enable = rdEnb;

  initial
    begin : reset_x_gen
      reset_x <= 1'b0;
      # (20);
      @ (posedge clk)
      # (2);
      reset_x <= 1'b1;
    end

  always 
    begin : clk_gen
      clk <= 1'b1;
      # (5);
      clk <= 1'b0;
      # (5);
      if (snkDone == 1'b1) begin
        clk <= 1'b1;
        # (5);
        clk <= 1'b0;
        # (5);
        $stop;
      end
    end

  BRAM_subsytem_interface_test u_BRAM_subsytem_interface_test (.clk(clk),
                                                               .reset_x(reset_x),
                                                               .clk_enable(clk_enable),
                                                               .GPIO(GPIO),
                                                               .ce_out(ce_out),
                                                               .bram_din(bram_din),  // uint32
                                                               .bram_addr(bram_addr),  // uint16
                                                               .bram_en(bram_en),
                                                               .PL_done(PL_done)
                                                               );

  assign bram_din_enb = ce_out & bram_din_active;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 266664
  always @(posedge clk)
    begin : c_2_process
      if (reset_x == 1'b0) begin
        bram_din_addr <= 19'b0000000000000000000;
      end
      else begin
        if (bram_din_enb) begin
          if (bram_din_addr >= 19'b1000001000110101000) begin
            bram_din_addr <= 19'b0000000000000000000;
          end
          else begin
            bram_din_addr <= bram_din_addr + 19'b0000000000000000001;
          end
        end
      end
    end



  assign bram_din_lastAddr = bram_din_addr >= 19'b1000001000110101000;



  assign bram_din_done = bram_din_lastAddr & reset_x;



  // Delay to allow last sim cycle to complete
  always @(posedge clk)
    begin : checkDone_1
      if (!reset_x) begin
        check1_done <= 0;
      end
      else begin
        if (bram_din_done_enb) begin
          check1_done <= bram_din_done;
        end
      end
    end

  assign snkDone = check4_done & (check3_done & (check1_done & check2_done));



  assign #1 bram_din_addr_delay_1 = bram_din_addr;

  // Data source for bram_din_expected
  initial
    begin : bram_din_expected_fileread
      fp_bram_din_expected = $fopen("bram_din_expected.dat", "r");
      status_bram_din_expected = $rewind(fp_bram_din_expected);
    end

  always @(bram_din_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        bram_din_expected <= 32'bx;
      end
      else if (ce_out == 1) begin
        status_bram_din_expected = $fscanf(fp_bram_din_expected, "%h", bram_din_expected);
      end
    end

  assign bram_din_ref = bram_din_expected;

  always @(posedge clk)
    begin : bram_din_checker
      if (reset_x == 1'b0) begin
        bram_din_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && bram_din !== bram_din_ref) begin
          bram_din_testFailure <= 1'b1;
          $display("ERROR in bram_din at time %t : Expected '%h' Actual '%h'", $time, bram_din_ref, bram_din);
        end
      end
    end

  assign #1 bram_addr_addr_delay_1 = bram_din_addr;

  // Data source for bram_addr_expected
  initial
    begin : bram_addr_expected_fileread
      fp_bram_addr_expected = $fopen("bram_addr_expected.dat", "r");
      status_bram_addr_expected = $rewind(fp_bram_addr_expected);
    end

  always @(bram_addr_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        bram_addr_expected <= 16'bx;
      end
      else if (ce_out == 1) begin
        status_bram_addr_expected = $fscanf(fp_bram_addr_expected, "%h", bram_addr_expected);
      end
    end

  assign bram_addr_ref = bram_addr_expected;

  always @(posedge clk)
    begin : bram_addr_checker
      if (reset_x == 1'b0) begin
        bram_addr_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && bram_addr !== bram_addr_ref) begin
          bram_addr_testFailure <= 1'b1;
          $display("ERROR in bram_addr at time %t : Expected '%h' Actual '%h'", $time, bram_addr_ref, bram_addr);
        end
      end
    end

  assign #1 bram_en_addr_delay_1 = bram_din_addr;

  // Data source for bram_en_expected
  initial
    begin : bram_en_expected_fileread
      fp_bram_en_expected = $fopen("bram_en_expected.dat", "r");
      status_bram_en_expected = $rewind(fp_bram_en_expected);
    end

  always @(bram_en_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        bram_en_expected <= 1'bx;
      end
      else if (ce_out == 1) begin
        status_bram_en_expected = $fscanf(fp_bram_en_expected, "%h", bram_en_expected);
      end
    end

  assign bram_en_ref = bram_en_expected;

  always @(posedge clk)
    begin : bram_en_checker
      if (reset_x == 1'b0) begin
        bram_en_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && bram_en !== bram_en_ref) begin
          bram_en_testFailure <= 1'b1;
          $display("ERROR in bram_en at time %t : Expected '%h' Actual '%h'", $time, bram_en_ref, bram_en);
        end
      end
    end

  assign #1 PL_done_addr_delay_1 = bram_din_addr;

  // Data source for PL_done_expected
  initial
    begin : PL_done_expected_fileread
      fp_PL_done_expected = $fopen("PL_done_expected.dat", "r");
      status_PL_done_expected = $rewind(fp_PL_done_expected);
    end

  always @(PL_done_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        PL_done_expected <= 1'bx;
      end
      else if (ce_out == 1) begin
        status_PL_done_expected = $fscanf(fp_PL_done_expected, "%h", PL_done_expected);
      end
    end

  assign PL_done_ref = PL_done_expected;

  always @(posedge clk)
    begin : PL_done_checker
      if (reset_x == 1'b0) begin
        PL_done_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && PL_done !== PL_done_ref) begin
          PL_done_testFailure <= 1'b1;
          $display("ERROR in PL_done at time %t : Expected '%h' Actual '%h'", $time, PL_done_ref, PL_done);
        end
      end
    end

  assign testFailure = PL_done_testFailure | (bram_en_testFailure | (bram_din_testFailure | bram_addr_testFailure));



  always @(posedge clk)
    begin : completed_msg
      if (snkDone == 1'b1) begin
        if (testFailure == 1'b0) begin
          $display("**************TEST COMPLETED (PASSED)**************");
        end
        else begin
          $display("**************TEST COMPLETED (FAILED)**************");
        end
      end
    end

endmodule  // BRAM_subsytem_interface_test_tb

