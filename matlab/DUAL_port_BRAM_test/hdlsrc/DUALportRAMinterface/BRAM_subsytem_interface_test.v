// -------------------------------------------------------------
// 
// File Name: DUAL_port_BRAM_test\hdlsrc\DUALportRAMinterface\BRAM_subsytem_interface_test.v
// Created: 2024-05-13 21:12:25
// 
// Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 7.50008e-06
// Target subsystem base rate: 7.50008e-06
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        7.50008e-06
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// bram_din                      ce_out        7.50008e-06
// bram_addr                     ce_out        7.50008e-06
// bram_en                       ce_out        7.50008e-06
// PL_done                       ce_out        7.50008e-06
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: BRAM_subsytem_interface_test
// Source Path: DUALportRAMinterface/BRAM_subsytem_interface_test
// Hierarchy Level: 0
// Model version: 1.26
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module BRAM_subsytem_interface_test
          (clk,
           reset_x,
           clk_enable,
           GPIO,
           ce_out,
           bram_din,
           bram_addr,
           bram_en,
           PL_done);


  input   clk;
  input   reset_x;
  input   clk_enable;
  input   GPIO;
  output  ce_out;
  output  [31:0] bram_din;  // uint32
  output  [15:0] bram_addr;  // uint16
  output  bram_en;
  output  PL_done;


  wire enb;
  reg  [19999:0] Delay_reg;  // ufix1 [20000]
  wire Delay_out1;
  wire counter_reset;
  wire counter_reset_1;
  wire [15:0] index_counter_out1;  // uint16
  wire counter_increment;
  wire write_enable;
  wire counter_increment_1;
  wire [31:0] Constant11_out1;  // uint32
  wire [31:0] Constant10_out1;  // uint32
  wire [31:0] Constant1_out1;  // uint32
  wire [31:0] Constant2_out1;  // uint32
  wire [31:0] Constant6_out1;  // uint32
  wire [31:0] Constant7_out1;  // uint32
  wire [31:0] Constant8_out1;  // uint32
  wire [31:0] Constant9_out1;  // uint32
  wire [31:0] Constant15_out1;  // uint32
  wire [31:0] Multiport_Switch_out1;  // uint32
  wire write_enable_1;
  reg  [15:0] Delay1_reg;  // ufix1 [16]
  wire Delay1_out1;


  assign enb = clk_enable;

  always @(posedge clk)
    begin : Delay_process
      if (reset_x == 1'b0) begin
        Delay_reg <= {20000{1'b0}};
      end
      else begin
        if (enb) begin
          Delay_reg[0] <= GPIO;
          Delay_reg[32'sd19999:32'sd1] <= Delay_reg[32'sd19998:32'sd0];
        end
      end
    end

  assign Delay_out1 = Delay_reg[19999];



  assign counter_reset_1 = counter_reset;

  Chart u_Chart (.clk(clk),
                 .reset_x(reset_x),
                 .enb(clk_enable),
                 .GA_done(Delay_out1),
                 .GPIO(GPIO),
                 .counter(index_counter_out1),  // uint16
                 .counter_increment(counter_increment),
                 .counter_reset(counter_reset),
                 .write_enable(write_enable)
                 );

  assign counter_increment_1 = counter_increment;

  index_counter u_index_counter (.clk(clk),
                                 .reset_x(reset_x),
                                 .enb(clk_enable),
                                 .In1(counter_increment_1),
                                 .In2(counter_reset_1),
                                 .index_counter_1(index_counter_out1)  // uint16
                                 );

  assign Constant11_out1 = 32'b00000000000000000000011111010000;



  assign Constant10_out1 = 32'b00000000000000000010111011100000;



  assign Constant1_out1 = 32'b00000000000000000010001100101000;



  assign Constant2_out1 = 32'b00000000000000000000111110100000;



  assign Constant6_out1 = 32'b00000000000000000001011101110000;



  assign Constant7_out1 = 32'b00000000000000000011001011001000;



  assign Constant8_out1 = 32'b00000000000000000001101101011000;



  assign Constant9_out1 = 32'b00000000000000000001001110001000;



  assign Constant15_out1 = 32'b00000000000000000000000000000000;



  assign Multiport_Switch_out1 = (index_counter_out1 == 16'b0000000000000000 ? Constant11_out1 :
              (index_counter_out1 == 16'b0000000000000001 ? Constant10_out1 :
              (index_counter_out1 == 16'b0000000000000010 ? Constant1_out1 :
              (index_counter_out1 == 16'b0000000000000011 ? Constant2_out1 :
              (index_counter_out1 == 16'b0000000000000100 ? Constant6_out1 :
              (index_counter_out1 == 16'b0000000000000101 ? Constant7_out1 :
              (index_counter_out1 == 16'b0000000000000110 ? Constant8_out1 :
              (index_counter_out1 == 16'b0000000000000111 ? Constant9_out1 :
              Constant15_out1))))))));



  assign bram_din = Multiport_Switch_out1;

  assign bram_addr = index_counter_out1;

  assign write_enable_1 = write_enable;

  assign bram_en = write_enable_1;

  always @(posedge clk)
    begin : Delay1_process
      if (reset_x == 1'b0) begin
        Delay1_reg <= {16{1'b0}};
      end
      else begin
        if (enb) begin
          Delay1_reg[0] <= Delay_out1;
          Delay1_reg[32'sd15:32'sd1] <= Delay1_reg[32'sd14:32'sd0];
        end
      end
    end

  assign Delay1_out1 = Delay1_reg[15];



  assign PL_done = Delay1_out1;

  assign ce_out = clk_enable;

endmodule  // BRAM_subsytem_interface_test

