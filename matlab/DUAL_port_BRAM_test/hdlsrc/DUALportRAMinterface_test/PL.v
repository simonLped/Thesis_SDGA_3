// -------------------------------------------------------------
// 
// File Name: DUAL_port_BRAM_test\hdlsrc\DUALportRAMinterface_test\PL.v
// Created: 2024-05-15 22:08:20
// 
// Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 7.50008e-06
// Target subsystem base rate: 7.50008e-06
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        7.50008e-06
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// bram_din                      ce_out        7.50008e-06
// bram_addr                     ce_out        7.50008e-06
// bram_en                       ce_out        7.50008e-06
// PL_done                       ce_out        7.50008e-06
// bram_we                       ce_out        7.50008e-06
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: PL
// Source Path: DUALportRAMinterface_test/PL
// Hierarchy Level: 0
// Model version: 1.58
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module PL
          (clk,
           reset_x,
           clk_enable,
           START_GA,
           bram_dout,
           ce_out,
           bram_din,
           bram_addr,
           bram_en,
           PL_done,
           bram_we);


  input   clk;
  input   reset_x;
  input   clk_enable;
  input   START_GA;
  input   [31:0] bram_dout;  // uint32
  output  ce_out;
  output  [31:0] bram_din;  // uint32
  output  [15:0] bram_addr;  // uint16
  output  bram_en;
  output  PL_done;
  output  [3:0] bram_we;  // ufix4


  wire enb;
  wire Constant_out1;
  wire counter_reset;
  wire counter_reset_1;
  wire [15:0] index_counter_out1;  // uint16
  wire counter_increment;
  wire enable_store;
  wire PL_done_1;
  wire write_enable;
  wire counter_increment_1;
  reg [31:0] Delay5_reg [0:5];  // ufix32 [6]
  reg [31:0] Delay5_reg_next [0:5];  // ufix32 [6]
  reg [31:0] Delay5_out1;  // uint32
  wire [31:0] Constant1_out1;  // uint32
  wire [31:0] Add_out1;  // uint32
  reg [31:0] Delay4_reg [0:4];  // ufix32 [5]
  reg [31:0] Delay4_reg_next [0:4];  // ufix32 [5]
  reg [31:0] Delay4_out1;  // uint32
  wire [31:0] Add1_out1;  // uint32
  reg [31:0] Delay3_reg [0:3];  // ufix32 [4]
  reg [31:0] Delay3_reg_next [0:3];  // ufix32 [4]
  reg [31:0] Delay3_out1;  // uint32
  wire [31:0] Add2_out1;  // uint32
  reg [31:0] Delay2_reg [0:2];  // ufix32 [3]
  reg [31:0] Delay2_reg_next [0:2];  // ufix32 [3]
  reg [31:0] Delay2_out1;  // uint32
  wire [31:0] Add3_out1;  // uint32
  reg [31:0] Delay1_reg [0:1];  // ufix32 [2]
  wire [31:0] Delay1_reg_next [0:1];  // ufix32 [2]
  wire [31:0] Delay1_out1;  // uint32
  wire [31:0] Add4_out1;  // uint32
  reg [31:0] Delay_out1;  // uint32
  wire [31:0] Add5_out1;  // uint32
  wire [31:0] Add6_out1;  // uint32
  wire [31:0] individual1_out1;  // uint32
  wire [31:0] individual1_out2;  // uint32
  wire [31:0] individual1_out3;  // uint32
  wire [31:0] individual1_out4;  // uint32
  wire [31:0] individual1_out5;  // uint32
  wire [31:0] individual1_out6;  // uint32
  wire [31:0] individual1_out7;  // uint32
  wire [31:0] Multiport_Switch_out1;  // uint32
  wire write_enable_1;
  wire write_enable_2;
  wire [3:0] y;  // ufix4
  reg signed [31:0] Delay5_t_0_0;  // int32
  reg signed [31:0] Delay5_t_0_1;  // int32
  reg signed [31:0] Delay5_t_1;  // int32
  reg signed [31:0] Delay4_t_0_0;  // int32
  reg signed [31:0] Delay4_t_0_1;  // int32
  reg signed [31:0] Delay4_t_1;  // int32
  reg signed [31:0] Delay3_t_0_0;  // int32
  reg signed [31:0] Delay3_t_0_1;  // int32
  reg signed [31:0] Delay3_t_1;  // int32
  reg signed [31:0] Delay2_t_0_0;  // int32
  reg signed [31:0] Delay2_t_0_1;  // int32
  reg signed [31:0] Delay2_t_1;  // int32
  reg signed [31:0] Delay1_t_0_0;  // int32
  reg signed [31:0] Delay1_t_1;  // int32


  assign Constant_out1 = 1'b1;



  assign counter_reset_1 = counter_reset;

  Chart u_Chart (.clk(clk),
                 .reset_x(reset_x),
                 .enb(clk_enable),
                 .GA_done(Constant_out1),
                 .GPIO(START_GA),
                 .counter(index_counter_out1),  // uint16
                 .counter_increment(counter_increment),
                 .counter_reset(counter_reset),
                 .enable_store(enable_store),
                 .PL_done(PL_done_1),
                 .write_enable(write_enable)
                 );

  assign counter_increment_1 = counter_increment;

  index_counter u_index_counter (.clk(clk),
                                 .reset_x(reset_x),
                                 .enb(clk_enable),
                                 .In1(counter_increment_1),
                                 .In2(counter_reset_1),
                                 .index_counter_1(index_counter_out1)  // uint16
                                 );

  assign enb = clk_enable;

  always @(posedge clk)
    begin : Delay5_process
      if (reset_x == 1'b0) begin
        for(Delay5_t_1 = 32'sd0; Delay5_t_1 <= 32'sd5; Delay5_t_1 = Delay5_t_1 + 32'sd1) begin
          Delay5_reg[Delay5_t_1] <= 32'b00000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay5_t_0_1 = 32'sd0; Delay5_t_0_1 <= 32'sd5; Delay5_t_0_1 = Delay5_t_0_1 + 32'sd1) begin
            Delay5_reg[Delay5_t_0_1] <= Delay5_reg_next[Delay5_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay5_out1 = Delay5_reg[5];
    Delay5_reg_next[0] = bram_dout;

    for(Delay5_t_0_0 = 32'sd0; Delay5_t_0_0 <= 32'sd4; Delay5_t_0_0 = Delay5_t_0_0 + 32'sd1) begin
      Delay5_reg_next[Delay5_t_0_0 + 32'sd1] = Delay5_reg[Delay5_t_0_0];
    end

  end



  assign Constant1_out1 = 32'b00000000000000000010011100010000;



  assign Add_out1 = Delay5_out1 + Constant1_out1;



  always @(posedge clk)
    begin : Delay4_process
      if (reset_x == 1'b0) begin
        for(Delay4_t_1 = 32'sd0; Delay4_t_1 <= 32'sd4; Delay4_t_1 = Delay4_t_1 + 32'sd1) begin
          Delay4_reg[Delay4_t_1] <= 32'b00000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay4_t_0_1 = 32'sd0; Delay4_t_0_1 <= 32'sd4; Delay4_t_0_1 = Delay4_t_0_1 + 32'sd1) begin
            Delay4_reg[Delay4_t_0_1] <= Delay4_reg_next[Delay4_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay4_out1 = Delay4_reg[4];
    Delay4_reg_next[0] = bram_dout;

    for(Delay4_t_0_0 = 32'sd0; Delay4_t_0_0 <= 32'sd3; Delay4_t_0_0 = Delay4_t_0_0 + 32'sd1) begin
      Delay4_reg_next[Delay4_t_0_0 + 32'sd1] = Delay4_reg[Delay4_t_0_0];
    end

  end



  assign Add1_out1 = Delay4_out1 + Constant1_out1;



  always @(posedge clk)
    begin : Delay3_process
      if (reset_x == 1'b0) begin
        for(Delay3_t_1 = 32'sd0; Delay3_t_1 <= 32'sd3; Delay3_t_1 = Delay3_t_1 + 32'sd1) begin
          Delay3_reg[Delay3_t_1] <= 32'b00000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay3_t_0_1 = 32'sd0; Delay3_t_0_1 <= 32'sd3; Delay3_t_0_1 = Delay3_t_0_1 + 32'sd1) begin
            Delay3_reg[Delay3_t_0_1] <= Delay3_reg_next[Delay3_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay3_out1 = Delay3_reg[3];
    Delay3_reg_next[0] = bram_dout;

    for(Delay3_t_0_0 = 32'sd0; Delay3_t_0_0 <= 32'sd2; Delay3_t_0_0 = Delay3_t_0_0 + 32'sd1) begin
      Delay3_reg_next[Delay3_t_0_0 + 32'sd1] = Delay3_reg[Delay3_t_0_0];
    end

  end



  assign Add2_out1 = Delay3_out1 + Constant1_out1;



  always @(posedge clk)
    begin : Delay2_process
      if (reset_x == 1'b0) begin
        for(Delay2_t_1 = 32'sd0; Delay2_t_1 <= 32'sd2; Delay2_t_1 = Delay2_t_1 + 32'sd1) begin
          Delay2_reg[Delay2_t_1] <= 32'b00000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay2_t_0_1 = 32'sd0; Delay2_t_0_1 <= 32'sd2; Delay2_t_0_1 = Delay2_t_0_1 + 32'sd1) begin
            Delay2_reg[Delay2_t_0_1] <= Delay2_reg_next[Delay2_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay2_out1 = Delay2_reg[2];
    Delay2_reg_next[0] = bram_dout;

    for(Delay2_t_0_0 = 32'sd0; Delay2_t_0_0 <= 32'sd1; Delay2_t_0_0 = Delay2_t_0_0 + 32'sd1) begin
      Delay2_reg_next[Delay2_t_0_0 + 32'sd1] = Delay2_reg[Delay2_t_0_0];
    end

  end



  assign Add3_out1 = Delay2_out1 + Constant1_out1;



  always @(posedge clk)
    begin : Delay1_process
      if (reset_x == 1'b0) begin
        for(Delay1_t_1 = 32'sd0; Delay1_t_1 <= 32'sd1; Delay1_t_1 = Delay1_t_1 + 32'sd1) begin
          Delay1_reg[Delay1_t_1] <= 32'b00000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay1_t_0_0 = 32'sd0; Delay1_t_0_0 <= 32'sd1; Delay1_t_0_0 = Delay1_t_0_0 + 32'sd1) begin
            Delay1_reg[Delay1_t_0_0] <= Delay1_reg_next[Delay1_t_0_0];
          end
        end
      end
    end

  assign Delay1_out1 = Delay1_reg[1];
  assign Delay1_reg_next[0] = bram_dout;
  assign Delay1_reg_next[1] = Delay1_reg[0];



  assign Add4_out1 = Delay1_out1 + Constant1_out1;



  always @(posedge clk)
    begin : Delay_process
      if (reset_x == 1'b0) begin
        Delay_out1 <= 32'b00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          Delay_out1 <= bram_dout;
        end
      end
    end



  assign Add5_out1 = Delay_out1 + Constant1_out1;



  assign Add6_out1 = bram_dout + Constant1_out1;



  individual1 u_individual1 (.clk(clk),
                             .reset_x(reset_x),
                             .enb(clk_enable),
                             .reg_in(Add_out1),  // uint32
                             .reg_in1(Add1_out1),  // uint32
                             .reg_in2(Add2_out1),  // uint32
                             .reg_in3(Add3_out1),  // uint32
                             .reg_in4(Add4_out1),  // uint32
                             .reg_in5(Add5_out1),  // uint32
                             .reg_in6(Add6_out1),  // uint32
                             .enable(enable_store),
                             .score(individual1_out1),  // uint32
                             .a2(individual1_out2),  // uint32
                             .a3(individual1_out3),  // uint32
                             .a4(individual1_out4),  // uint32
                             .b2(individual1_out5),  // uint32
                             .b3(individual1_out6),  // uint32
                             .b4(individual1_out7)  // uint32
                             );

  assign Multiport_Switch_out1 = (index_counter_out1 == 16'b0000000000000000 ? individual1_out1 :
              (index_counter_out1 == 16'b0000000000000001 ? individual1_out2 :
              (index_counter_out1 == 16'b0000000000000010 ? individual1_out3 :
              (index_counter_out1 == 16'b0000000000000011 ? individual1_out4 :
              (index_counter_out1 == 16'b0000000000000100 ? individual1_out5 :
              (index_counter_out1 == 16'b0000000000000101 ? individual1_out6 :
              (index_counter_out1 == 16'b0000000000000110 ? individual1_out7 :
              (index_counter_out1 == 16'b0000000000000111 ? individual1_out1 :
              individual1_out1))))))));



  assign bram_din = Multiport_Switch_out1;

  assign bram_addr = index_counter_out1;

  assign write_enable_1 = write_enable;

  assign bram_en = write_enable_1;

  assign PL_done = PL_done_1;

  assign write_enable_2 = write_enable;

  assign y = {write_enable_2, write_enable_2, write_enable_2, write_enable_2};



  assign bram_we = y;

  assign ce_out = clk_enable;

endmodule  // PL

